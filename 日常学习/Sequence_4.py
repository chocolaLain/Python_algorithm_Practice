# @Time    : 5/6 0006 17:56
# @Author  : Lain
# 基于队列的迷宫求解


from SStack import *
from Sequence_2 import *


maze1 = [
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    [1,0,1,1,0,0,0,0,0,1,0,0,0,0,0,0,1,0,0,1],
    [1,0,0,0,0,1,0,1,0,1,0,1,1,0,1,0,1,1,0,1],
    [1,1,1,1,1,1,0,1,0,1,0,0,0,0,1,0,0,0,0,1],
    [1,0,0,0,1,0,0,1,1,1,0,1,1,1,1,1,1,1,1,1],
    [1,1,1,0,1,0,1,0,0,1,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,1,0,1,0,1,1,1,0,1,1,1,1,1,1,0,1],
    [1,1,1,0,1,0,1,0,1,0,0,0,1,0,0,0,0,1,0,1],
    [1,0,0,0,0,0,1,0,1,0,1,1,1,0,1,1,0,1,0,1],
    [1,0,1,0,1,1,1,0,1,0,1,0,0,0,1,1,1,1,0,1],
    [1,0,1,0,1,0,0,0,1,0,1,0,1,0,0,1,0,0,0,1],
    [1,0,1,0,1,1,1,1,1,0,1,0,1,1,1,1,1,1,0,1],
    [1,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,1],
    [1,0,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,1,0,1],
    [1,1,1,1,0,1,1,1,0,1,0,1,1,1,0,1,0,1,0,1],
    [1,0,0,0,0,1,0,1,0,1,0,1,0,0,0,1,0,0,0,1],
    [1,0,1,1,0,1,0,1,0,1,0,1,0,1,1,1,1,1,1,1],
    [1,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,0,0,0,1],
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
]

maze2 = [
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    [1,0,0,0,1,1,0,0,0,1,0,0,0,1],
    [1,0,1,0,0,0,0,1,0,1,0,1,0,1],
    [1,0,1,0,1,1,1,1,0,1,0,1,0,1],
    [1,0,1,0,0,0,0,0,0,1,1,1,0,1],
    [1,0,1,1,1,1,1,1,1,1,0,0,0,1],
    [1,0,1,0,0,0,0,0,0,0,0,1,0,1],
    [1,0,0,0,1,1,1,0,1,0,1,1,0,1],
    [1,0,1,0,1,0,1,0,1,0,1,0,0,1],
    [1,0,1,0,1,0,1,0,1,1,1,1,0,1],
    [1,0,1,0,0,0,1,0,0,1,0,0,0,1],
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,]
]

dirs = [(0,1), (1, 0), (0, -1), (-1, 0)]


def mark(maze, pos):
    maze[pos[0]][pos[1]] = 2


def passable(maze, pos):
    return maze[pos[0]][pos[1]] == 0


def build_path(start, pos, end, precedent):
    path = [end]
    while pos != start:
        path.append(pos)
        pos = precedent[pos]
    path.append(start)
    path.reverse()
    return path


def maze_solver_queue1(maze, start, end):
    if start == end:
        return [start]
    qu = SQueue()
    precedent = dict()
    mark(maze, start)
    qu.enqueue(start)
    while not qu.is_empty():
        pos = qu.dequeue()
        for i in range(4):
            nextp = (pos[0] + dirs[i][0],
                     pos[1] + dirs[i][1])
            if passable(maze, nextp):
                if nextp == end:
                    return build_path(start, pos, end, precedent)
                mark(maze, nextp)
                precedent[nextp] = pos
                qu.enqueue(nextp)

    print("No path.")


if __name__ == '__main__':
    print(maze_solver_queue1(maze1, (1,1), (18,18)))

